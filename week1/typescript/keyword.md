# REPL
    REPLì€ Read-Eval-Print-Loopì˜ ì•½ìë¡œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ìƒíƒœì—ì„œ ì‚¬ìš©ìê°€ ì…ë ¥í•œ ëª…ë ¹ì–´(ì†ŒìŠ¤ì½”ë“œ)ë¥¼ ì½ê³ (Read) ëª…ë ¹ì–´ë¥¼ í‰ê°€(Eval)í•˜ê³  ê²°ê³¼ë¥¼ ì¶œë ¥(Print)í•œ ë‹¤ìŒ ë‹¤ì‹œ ì…ë ¥ì„ ê¸°ë‹¤ë¦¬ëŠ” ìƒíƒœë¡œ ëŒì•„ê°€ëŠ” ê³¼ì •ì„ ë°˜ë³µ(Loop)í•œë‹¤.
    ì¦‰ ì…ë ¥ í›„ ì¦‰ê°ì ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆëŠ” ë°©ì‹

    ex) í„°ë¯¸ë„ì—ì„œ Nodeë¼ê³  ì¹˜ë©´ ì¦‰ê°ì ìœ¼ë¡œ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ

# TypeScript
    íƒ€ì…ìŠ¤í¬ë¦½íŠ¸(TypeScript)ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ìŠˆí¼ì…‹ì¸ ì˜¤í”ˆì†ŒìŠ¤ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì´ë‹¤. ë§ˆì´í¬ë¡œì†Œí”„íŠ¸ì—ì„œ ê°œë°œ, ìœ ì§€í•˜ê³  ìˆìœ¼ë©° ì—„ê²©í•œ ë¬¸ë²•ì„ ì§€ì›í•œë‹¤. C#ì˜ ë¦¬ë“œ ì•„í‚¤í…íŠ¸ì´ì ë¸íŒŒì´, í„°ë³´ íŒŒìŠ¤ì¹¼ì˜ ì°½ì‹œìì¸ Anders Hejlsbergê°€ ê°œë°œì— ì°¸ì—¬í•œë‹¤. í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œì™€ ì„œë²„ ì‚¬ì´ë“œë¥¼ ìœ„í•œ ê°œë°œì— ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ì—”ì§„ì„ ì‚¬ìš©í•˜ë©´ì„œ ì»¤ë‹¤ë€ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•  ìˆ˜ ìˆê²Œ ì„¤ê³„ëœ ì–¸ì–´ì´ë‹¤. ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ìŠˆí¼ì…‹ì´ê¸° ë•Œë¬¸ì— ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ í”„ë¡œê·¸ë¨ìœ¼ë¡œë„ ë™ì‘í•œë‹¤.
íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ìì‹ ì´ ì›í•˜ëŠ” íƒ€ì…ì„ ì •ì˜í•˜ê³  í”„ë¡œê·¸ë˜ë°ì„ í•˜ë©´ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì»´íŒŒì¼ë˜ì–´ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ëª¨ë“  ìš´ì˜ ì²´ì œ, ëª¨ë“  ë¸Œë¼ìš°ì €, ëª¨ë“  í˜¸ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜¤í”ˆ ì†ŒìŠ¤ì´ë‹¤.

## ì¸í„°í˜ì´ìŠ¤ì™€ íƒ€ì…ì˜ ì°¨ì´
### ì„ ì–¸ì  í™•ì¥
interfaceì—ì„œ í•  ìˆ˜ ìˆëŠ” ëŒ€ë¶€ë¶„ì˜ ê¸°ëŠ¥ë“¤ì€ typeì—ì„œ ê°€ëŠ¥í•˜ì§€ë§Œ, í•œ ê°€ì§€ ì¤‘ìš”í•œ ì°¨ì´ì ì€ typeì€ ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•˜ê¸° ìœ„í•´ì„œ ë‹¤ì‹œ ê°™ì€ ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ì—†ì§€ë§Œ, interfaceëŠ” í•­ìƒ ì„ ì–¸ì  í™•ì¥ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì´ë‹¤.
### íƒ€ì… ì¶”ë¡ 
    íƒ€ì… ì¶”ë¡ ì´ë€ TypeScriptì—ì„œ ëª…ì‹œì ì¸ íƒ€ì… í‘œê¸°ê°€ ì—†ì„ ë•Œ íƒ€ì… ì •ë³´ë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ê²ƒì´ë‹¤.

ì‰½ê²Œ ë§í•˜ë©´ ìë™ìœ¼ë¡œ íƒ€ì…ì„ ê²°ì •í•´ì£¼ëŠ” ê²ƒì´ë¼ê³  ë³´ë©´ ëœë‹¤.
```tsx
let x = 3; // let x: number
let y = "4"; // let y: string
```
ì´ëŸ° ì‹ìœ¼ë¡œ javascriptì²˜ëŸ¼ ì‚¬ìš©í•˜ë©´ typescriptëŠ” ìë™ì ìœ¼ë¡œ íƒ€ì…ì„ ì¶”ë¡ í•˜ì—¬ ì•Œë§ì€ íƒ€ì…ì„ ê²°ì •í•œë‹¤.

ê·¸ë¦¬ê³  ì—¬ëŸ¬ íƒ€ì…ì„ ë™ì‹œì— ì‚¬ìš©í•  ê²½ìš° ìµœì  ê³µí†µ íƒ€ì…ì„ ì•Œì•„ì„œ ê³„ì‚°í•´ì¤€ë‹¤.

```tsx
let x = [0, 1, null]; // let x: (number | null)[]
```
ë˜í•œ ë¬¸ë§¥ì„ ì²´í¬í•˜ì—¬ íƒ€ì…ì„ ê²°ì •ì§“ê¸°ë„ í•œë‹¤.

# Union Type vs Intersection Type

### ğŸ· ìš”ì•½
Intersection â†’ And : A & B : Aíƒ€ì…ì´ë©´ì„œ Bíƒ€ì…, ì¦‰ ë‘ íŠ¹ì„± ëª¨ë‘ë¥¼ ì§€ë‹Œ íƒ€ì…

Union â†’ Or : A | B : Aíƒ€ì…, B íƒ€ì… ë‘˜ ì¤‘ í•˜ë‚˜, ì¦‰ ë‘˜ ì¤‘ ì–´ëŠ í•˜ë‚˜ë§Œì´ ì˜¬ ìˆ˜ ìˆëŠ” íƒ€ì…

## ğŸ“ Union Type
```tsx
let one: string | number | boolean;
 
one = 1;
one = '1';
one = true;
```
- | ë¥¼ ì‚¬ìš©
- Type A, Type Bê°€ ìˆì„ ë•Œ Aì™€ Bë¥¼ ìœ ë‹ˆì˜¨ í•˜ë©´ Aíƒ€ì… ë˜ëŠ” B íƒ€ì… ë‘˜ ì¤‘ í•˜ë‚˜
one: stringì´ê±°ë‚˜ number ë‘˜ ì¤‘ í•˜ë‚˜

## ğŸ“• Union Type ì–¸ì œ ì‚¬ìš©í• ê¹Œ?
```tsx
type A = string | number;
 
// An interface can only extend an object type or intersection of object types with statically known members.
interface StrOrNum extends A {
    a: string;
}
 
// Ok
type StrOrNum = {
    a: string;
} & (string | number);
interface Animal {
  eat: () => void;
  sleep: () => void;
}
 
interface Human {
  think: () => void;
}
 
type Developer = (Animal | Human) & {
  work: () => void;
};
```
ì—¬ëŸ¬ íƒ€ì… ì¤‘ í•˜ë‚˜ê°€ ì˜¬ ê²ƒì´ë¼ê³  ê°€ì •í•  ë•Œ ì‚¬ìš©
ë‹¨, ì¸í„°í˜ì´ìŠ¤ì— ìœ ë‹ˆì˜¨ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì¸í„°í˜ì´ìŠ¤ ìœ ë‹ˆì˜¨ íƒ€ì…ì„ í™•ì¥í•˜ì§€ ëª»í•¨
ì´ëŸ´ ë•ŒëŠ” type aliasì™€ &ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨
 

## ğŸ“• Union TypeëŠ” ë™ì‹œì— ì—¬ëŸ¬ íƒ€ì…ì´ ë  ìˆ˜ ì—†ë‹¤.
```tsx
type Human = {
    think: () => void;
};
 
type Dog = {
    bark: () => void;
}
declare function getEliceType(): Human | Dog; // ë°˜í™˜ íƒ€ì…ì´ Human or Dogì¸ getEliceType í•¨ìˆ˜
 
const elice = getEliceType(); // getEliceType í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ê²°ê³¼ë¥¼ elice ë¼ëŠ” ë³€ìˆ˜ì— í• ë‹¹
 
// Property 'think' does not exist on type 'Human | Dog'.
elice.think();
 
// Property 'bark' does not exist on type 'Human | Dog'.
elice.bark();
```
eliceë¥¼ Human or Dogë¼ëŠ” ìœ ë‹ˆì˜¨ íƒ€ì…ìœ¼ë¡œ ë§Œë“¤ì–´ ì£¼ì–´ë„ think, bark ë‘˜ ì¤‘ ì–´ëŠ ê²ƒë„ ì‚¬ìš©í•˜ì§€ ëª»í•¨
why? â†’ eliceê°€ ëŸ°íƒ€ì„ì—ì„œ Humanì¸ì§€ Dogì¸ì§€ í™•ì‹ í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—
elice.think() í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ eliceê°€ Humanì´ë¼ë©´ ê´œì°®ì§€ë§Œ Dogë¼ë©´ thinkë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì—ëŸ¬
í•´ê²° ë°©ë²• : íƒ€ì… ê°€ë“œ â‡’ eliceê°€ Human ì¼ ë•Œ thinkí•¨ìˆ˜ë¥¼, Dog ì¼ ë•Œ barkí•¨ìˆ˜ë¥¼
 

## ğŸ“ Intersection Type
```tsx
type Human = {
    think: () => void;
};
 
type Developer = {
    word: () => void;
}
 
const elice: Human & Developer = {
    think() {
        console.log("ìƒê° ì¤‘");
    } ,
    word() {
        console.log("ì—…ë¬´ ì¤‘");
    } 
}
```
ê¸°ì¡´ íƒ€ì…ì„ ëŒ€ì²´í•˜ì§€ ì•Šìœ¼ë©´ì„œ ê¸°ì¡´ íƒ€ì…ì— ìƒˆë¡œìš´ í•„ë“œë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©
êµì°¨ íƒ€ì…(Intersection Type)ì€ &(ì•°í¼ìƒŒë“œ)ë¥¼ ì‚¬ìš©í•œë‹¤.
Type A, Type Bê°€ ìˆì„ ë•Œ Aì™€ Bë¥¼ ì¸í„°ì„¹ì…˜ í•˜ë©´ Aíƒ€ì…ì´ë©´ì„œ Bíƒ€ì…ì´ë¼ëŠ” ì˜ë¯¸
ì¦‰, EliceëŠ” Humanì´ë©´ì„œ Developerë¼ì„œ ë‘ ê°œì˜ ì†ì„±ì„ ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
 

## ğŸ“• Intersection TypeëŠ” ì–¸ì œ ì‚¬ìš©í• ê¹Œ?
```tsx
type Human = {
    think: () => void;
};
 
type Developer = {
    word: () => void;
}
 
type Student = {
    study: () => void;
}
 
const elice: Human & Developer & Student = {
    think() {
        console.log("ìƒê° ì¤‘");
    } ,
    word() {
        console.log("ì—…ë¬´ ì¤‘"); 
    } ,
    study() {
        console.log("ê³µë¶€ ì¤‘");
    } 
}
```
Intersection Typeì€ ê¸°ì¡´ íƒ€ì…ì„ ëŒ€ì²´í•˜ì§€ ì•Šìœ¼ë©´ì„œ ê¸°ì¡´ íƒ€ì…ì— ìƒˆë¡œìš´ í•„ë“œë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš© â‡’ í™•ì¥í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©
ê¸°ì¡´ì˜ Human & Developer íƒ€ì…ì˜ eliceì— student íƒ€ì…ì„ ì¶”ê°€í•´ ê¸°ì¡´ íƒ€ì…ì€ ë³€ê²½í•˜ì§€ ì•Šê³  í™•ì¥ ê°€ëŠ¥
 

## ğŸ“• Intersection Type ì£¼ì˜í•  ì  : ê° íƒ€ì…ì— ê²¹ì¹˜ëŠ” í•„ë“œê°€ ìˆë‹¤ë©´ ì–´ë–»ê²Œ ë ê¹Œ?
ğŸ›  íƒ€ì…ì´ ê°™ì„ ë•Œ : Ok

```tsx
type Developer = {
    output: string;
    developer: () => void;
}
 
type Designer = {
    output: string;
    design: () => void;
}
 
const ê°œìì´ë„ˆ: Developer & Designer = {
    output: 'sth cool', // ok
    developer() {
        console.log("ì—…ë¬´ ì¤‘");
    },
    design() {
        console.log("ì—…ë¬´ ì¤‘");
    }
}
```
ê°€ëŠ¥
 

### ğŸ›  íƒ€ì…ì´ ë‹¤ë¥¼ ë•Œ : Error
```tsx
type Developer = {
    output: number; // ** 
    developer: () => void;
}
 
type Designer = {
    output: string;
    design: () => void;
}
 
const ê°œìì´ë„ˆ: Developer & Designer = {
    output: 'sth cool', // error
    developer() {
        console.log("ì—…ë¬´ ì¤‘");
    },
    design() {
        console.log("ì—…ë¬´ ì¤‘");
    }
}
```
ì—ëŸ¬
 

### ğŸ›  íƒ€ì…ì´ í¬í•¨ê´€ê³„ì¼ ë•Œ : Ok or Error
```tsx
type Developer = {
    output: number; // ** 
    developer: () => void;
}
 
type Designer = {
    output: string | number; // ** 
    design: () => void;
}
 
const ê°œìì´ë„ˆ: Developer & Designer = {
    // output: 'sth cool', // error
    output: 1, // ok (string | number) & number ì´ë¼ì„œ number typeì€ ok!
    developer() {
        console.log("ì—…ë¬´ ì¤‘");
    },
    design() {
        console.log("ì—…ë¬´ ì¤‘");
    }
}
```
(string | number) & numberì´ë¼ì„œ number typeì€ ok!
 

